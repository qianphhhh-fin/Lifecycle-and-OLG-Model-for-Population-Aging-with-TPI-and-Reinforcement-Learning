%% MATLAB 脚本：验证生命周期模型中的价值函数近似
% =========================================================================
% 目的:
% 通过数值方法求解三期生命周期模型的第2期决策，以验证以下近似的合理性：
% V2(W2, P2) ≈ (1+β)ln(W2 + Ψ*P2) + K
%
% 核心验证方法:
% 该近似的一个关键推论是，最优风险资产配置比例 α2* 是一个不依赖于
% 状态变量 (W2, P2) 的常数。本脚本将计算“真实”的、依赖于状态的
% 策略函数 α2*(W2, P2)，并将其可视化。
%
% 如何解读结果:
% - 如果生成的 α2* 曲面图非常平坦，则说明近似是高度合理的。
% - 如果曲面有轻微的倾斜或弯曲，说明近似在一定误差范围内是可接受的。
% - 如果曲面有剧烈的变化，则说明背景风险显著，近似在该参数设定下失效。
%
% =========================================================================

%% 1. 初始化
clc;
clear;
close all;

fprintf('开始验证价值函数近似的合理性...\n');

%% 2. 设定模型参数
% -------------------------------------------------------------------------
% (你可以修改这些参数来测试不同经济环境下的近似效果)
% -------------------------------------------------------------------------

% 偏好参数
beta = 0.96;  % 时间偏好因子

% 经济与政策参数
Y1 = 1.0;     % 第1期收入
Y2 = 1.0;     % 第2期收入 (为简化，假设确定)
tau = 0.2;    % 当期所得税率
tau_p = 0.15; % 养老金领取期税率

% 资产回报参数 (核心)
p = 0.5;              % “好”状态 (H) 的概率
R_f = 1.02;           % 无风险总回报

R_s_H = 1.15;         % 风险资产在 H 状态的回报
R_s_L = 0.95;         % 风险资产在 L 状态的回报

R_p_H = 1.08;         % 养老金在 H 状态的回报
R_p_L = 1.00;         % 养老金在 L 状态的回报

% 检查养老金风险低于市场风险的假设
if abs(R_p_H - R_p_L) >= abs(R_s_H - R_s_L)
    warning('参数设定可能不满足养老金风险更低的假设。');
end

%% 3. 构建状态空间网格 (t=2)
% -------------------------------------------------------------------------
% 我们需要为状态变量 (W2, P2) 创建一个二维网格
% -------------------------------------------------------------------------

nW = 50;  % 流动性财富 W2 的网格点数
nP = 50;  % 养老金财富 P2 的网格点数

% 设定 W2 和 P2 的合理范围
% W2 的来源: 第1期税后可支配收入储蓄后的增值
max_S1 = (1-tau) * Y1 * 0.8; % 假设最多储蓄80%
W2_max = max_S1 * R_s_H + (1-tau)*Y2; % 一个粗略的上限
W2_grid = linspace(0.1, W2_max, nW);

% P2 的来源: 第1期养老金缴存的增值
max_q1 = 0.2; % 假设养老金缴存比例上限
P2_max = max_q1 * Y1 * R_p_H; % 一个粗略的上限
P2_grid = linspace(0.01, P2_max, nP);

% 使用 meshgrid 创建二维网格矩阵，这对于后续的向量化计算至关重要
[WW2, PP2] = meshgrid(W2_grid, P2_grid);


%% 4. 求解“真实”模型：逆向归纳求解第2期
% -------------------------------------------------------------------------
% 核心步骤：对于网格上的每一个点 (W2, P2)，我们都进行一次数值最优化，
% 求解出该点的最优消费 C2* 和最优投资比例 α2*。
% -------------------------------------------------------------------------

% 初始化存储结果的矩阵
V2_true = zeros(nP, nW);      % 存储真实的价值函数
C2_policy = zeros(nP, nW);    % 存储最优消费策略
alpha2_policy = zeros(nP, nW);% 存储最优风险资产配置策略 (这是我们最关心的)

% 设置优化器 fmincon 的选项
options = optimoptions('fmincon', 'Display', 'none', 'Algorithm', 'sqp');

fprintf('正在进行数值最优化，求解每个状态点的最优策略...\n');
tic; % 开始计时

% 遍历所有状态点
for i = 1:nP
    for j = 1:nW
        % 提取当前状态点
        W2_current = WW2(i, j);
        P2_current = PP2(i, j);
        
        % 定义目标函数 (我们要最小化负的期望效用)
        % x(1) = C2, x(2) = alpha2
        objective_func = @(x) -objective_t2(x, W2_current, P2_current, beta, tau_p, ...
                                             p, R_f, R_s_H, R_s_L, R_p_H, R_p_L);
        
        % 设定决策变量的约束条件
        % 0 < C2 <= W2
        % 0 <= alpha2 <= 1
        x0 = [W2_current / 2; 0.5]; % 初始猜测值
        lb = [1e-6; 0];             % 下界 [C2_min, alpha2_min]
        ub = [W2_current; 1];       % 上界 [C2_max, alpha2_max]
        
        % 调用 fmincon 进行求解
        [x_opt, fval] = fmincon(objective_func, x0, [], [], [], [], lb, ub, [], options);
        
        % 存储结果
        V2_true(i, j) = -fval;
        C2_policy(i, j) = x_opt(1);
        alpha2_policy(i, j) = x_opt(2);
    end
    % 显示进度
    if mod(i, 5) == 0
       fprintf('已完成 %.0f%% ...\n', (i/nP)*100);
    end
end

toc; % 结束计时
fprintf('数值求解完成。\n\n');


%% 5. 分析与可视化结果
% -------------------------------------------------------------------------
% 这是验证的关键一步。我们将 α2*(W2, P2) 可视化。
% -------------------------------------------------------------------------

fprintf('生成结果图表与统计分析...\n');

% --- 核心图表：最优 α2 策略的曲面图 ---
figure('Name', '核心验证：最优α2策略函数', 'Position', [100, 100, 800, 600]);
surf(WW2, PP2, alpha2_policy);

% 格式化图表
colorbar;
xlabel('流动性财富 (W_2)', 'FontSize', 12);
ylabel('养老金财富 (P_2)', 'FontSize', 12);
zlabel('最优风险资产配置比例 (\alpha_2^*)', 'FontSize', 12);
title({'检验近似合理性: "真实"的最优 \alpha_2^*(W_2, P_2) 曲面', ...
       '如果此曲面接近水平面，则近似合理'}, 'FontSize', 14);
set(gca, 'FontSize', 11);
grid on;
view(30, 25); % 调整视角

% --- 辅助图表：最优 α2 策略的等高线图 ---
figure('Name', '最优α2策略等高线图', 'Position', [950, 100, 700, 600]);
contourf(WW2, PP2, alpha2_policy, 15); % 15个等高线层级

% 格式化图表
colorbar;
xlabel('流动性财富 (W_2)', 'FontSize', 12);
ylabel('养老金财富 (P_2)', 'FontSize', 12);
title({'最优 \alpha_2^*(W_2, P_2) 的等高线图', ...
       '如果颜色分布均匀，则近似合理'}, 'FontSize', 14);
set(gca, 'FontSize', 11);
grid on;

% --- 定量分析 ---
alpha_mean = mean(alpha2_policy(:));
alpha_std  = std(alpha2_policy(:));
alpha_min  = min(alpha2_policy(:));
alpha_max  = max(alpha2_policy(:));
alpha_cv   = alpha_std / alpha_mean; % 变异系数 (Coefficient of Variation)

fprintf('\n--- 定量分析结果 ---\n');
fprintf('在所选的状态空间网格上，最优α2策略的统计特性如下:\n');
fprintf(' - 平均值 (Mean)     : %.4f\n', alpha_mean);
fprintf(' - 标准差 (Std Dev)   : %.4f\n', alpha_std);
fprintf(' - 最小值 (Min)       : %.4f\n', alpha_min);
fprintf(' - 最大值 (Max)       : %.4f\n', alpha_max);
fprintf(' - 变异系数 (CV)      : %.4f\n', alpha_cv);
fprintf('\n');
fprintf('结论解读:\n');
fprintf('一个非常低的标准差和变异系数 (例如 < 0.05) 强力支持α2恒定的近似。\n');
fprintf('如果标准差很大，说明α2随财富状态变化显著，近似的合理性下降。\n');
fprintf('=========================================================================\n');


%% 6. 定义模型内部函数
% =========================================================================

% --- 第2期的目标函数 ---
function neg_utility = objective_t2(x, W2, P2, beta, tau_p, p, R_f, R_s_H, R_s_L, R_p_H, R_p_L)
    % 从输入向量 x 中分解出决策变量
    C2 = x(1);
    alpha2 = x(2);
    
    % 计算储蓄 S2
    S2 = W2 - C2;
    
    % 计算两种状态下的第3期财富 (消费) C3
    % C3 = S2 * R_s + P2 * R_p * (1-tau_p)
    
    % 好状态 (H)
    R_opt_H = (1 - alpha2) * R_f + alpha2 * R_s_H;
    C3_H = S2 * R_opt_H + (1 - tau_p) * P2 * R_p_H;
    
    % 坏状态 (L)
    R_opt_L = (1 - alpha2) * R_f + alpha2 * R_s_L;
    C3_L = S2 * R_opt_L + (1 - tau_p) * P2 * R_p_L;

    % 为避免log(非正数)导致计算错误，增加一个小的正数
    if C3_H <= 0 || C3_L <= 0
        neg_utility = 1e10; % 返回一个很大的值作为惩罚
        return;
    end
    
    % 计算期望效用 E[ln(C3)]
    expected_utility_C3 = p * log(C3_H) + (1 - p) * log(C3_L);
    
    % 计算第2期的总效用
    total_utility = log(C2) + beta * expected_utility_C3;
    
    % fmincon 需要最小化，因此返回负的效用
    neg_utility = -total_utility;
end